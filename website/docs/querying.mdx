---
title: Queries, Mutations & Subscriptions
sidebar_label: Queries, Mutations & Subscriptions
---

SwiftGraphQL lets you query data, perform mutations and even listen for subscriptions. Since queries and mutations don't differ much on the API level, they share the same method `send`. Subscriptions, on the other hand, use GraphQLSocket's `subscribe` method. Each of these has a type check that makes sure you can actually query what you are querying and mutating what is mutable.

When it comes to the usage flow, all three operations follow the same principle.

1. You create a query selection that tells the client what it should query and how it should decode the result.
1. Using `send` or `subscribe` you communicate with the server.

## Examples

```swift
let query = Selection.Query {
    let list = try $0.humans(human.list)
    let nullable = try $0.human(id: "100", human.nullable)

    return list
}

send(query, to: "http://localhost:4000") { result in
    if let data = try? result.get() {
        print(data)
    }
}

let subscription = Selection.Subscription {
    let list = try $0.humans(human.list)
    let nullable = try $0.human(id: "100", human.nullable)

    return list
}

// Initialize a socket
let socket = GraphQLSocket<URLSessionWebSocketTask>(.init(
    url: URL(string: "ws://localhost:4000/graphql")!,
    headers: [:],
    autoConnect: true
))
var cancellable: SocketCancellable?

// Open the socket and start listening
cancellable = socket.subscribe(to: subscription) { result in
    if let data = try? result.get() {
        print(data)
    }
}

// Close the socket.
cancellable = nil
socket?.stop()
```

> ❗️ NOTE: You should handle the closing of sockets. SwiftGraphQL intentionally doesn't handle websocket state and only implements the decoding and sending mechanism.
